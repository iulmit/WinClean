// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// <Auto-Generated>
// This is here so CodeMaid doesn't reorganize this document
// </Auto-Generated>

using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using CsvHelper;
using CsvHelper.Configuration;

namespace RaphaëlBardini.WinClean
{
    /// <summary>Provides CSV and TraceSource logging.</summary>
    public static class LogManager
    {

        #region Private Fields

        /// <summary>Représente la fenêtre des logs de Visual Studio</summary>
        private static readonly TraceSource s_trace = new($"{System.Windows.Forms.Application.ProductName} {System.Windows.Forms.Application.ProductVersion}", Constants.LOG_LEVEL);

        /// <summary>Count of log entries wrote.</summary>
        private static int s_logIndex = 0;

        private static readonly StreamWriter s_streamWriter = new(Constants.LOG_FILE_PATH, true, System.Text.Encoding.Unicode);
        private static readonly CsvWriter s_csvWriter = new(s_streamWriter, new CsvConfiguration(CultureInfo.InvariantCulture) { Delimiter = Constants.LOG_DELIMITER.ToString() });

        #endregion Private Fields

        #region Public Methods
        public static void ClearLogsFolder() => Directory.EnumerateFiles(Path.GetDirectoryName(Constants.LOG_FILE_PATH), "*.csv")
                        .Where((csvFile) => CanLogFileBeDeleted(csvFile))
                        .ForEach((path) =>
                        {
                            try
                            {
                                File.Delete(path);
                            }
                            catch (Exception e) when (e is DirectoryNotFoundException or UnauthorizedAccessException || e.GetType().Equals(typeof(IOException)))
                            {
                                e.Handle(Resources.ErrorMessages.CantDeleteLogFile);
                            }
                        });

        /// <summary>Logs a string.</summary>
        /// <param name="str">The string to log.</param>
        /// <param name="happening">What we're doing right now.</param>
        /// <param name="lvl">The level of the log entry.</param>
        /// <param name="caller">The name of the caller function.</param>
        /// <param name="callLine">The line of the call.</param>
        /// <param name="callFile">The file of the call.</param>
        public static void Log(this string str, string happening, TraceEventType lvl = TraceEventType.Verbose,
                                 [CallerMemberName] string caller = "\\Not Found\\",
                                 [CallerLineNumber] int callLine = 0,
                                 [CallerFilePath] string callFile = "\\Not Found\\")
        {
            Init();

            if (s_logIndex == 0)
                WriteHeader(s_csvWriter);
            s_csvWriter.WriteRecord(new LogEntry()
            {
                Date = DateTime.Now,
                Index = s_logIndex,
                Level = lvl,
                Happening = happening,
                Message = str,
                Caller = caller,
                CallFile = callFile,
                CallLine = callLine
            });
            s_csvWriter.NextRecord();

            s_trace.TraceEvent(lvl, s_logIndex, $"{happening} : {str} in {caller} at line {callLine}, in {callFile}");
            s_logIndex++;

            s_trace.Close();
        }

        #endregion Public Methods

        #region Private Methods

        /// <summary>Creates the appropriate log folder if missing.</summary>
        private static void Init()
        {
            try
            {
                _ = Directory.CreateDirectory(Path.GetDirectoryName(Constants.LOG_FILE_PATH));
            }
            catch (IOException e)
            {
                e.HandleDontLog(Resources.ErrorMessages.CantCreateLogDir, TraceEventType.Critical);
            }
        }
        private static void WriteHeader(in CsvWriter writer)
        {
            writer.WriteHeader<LogEntry>();
            writer.NextRecord();
            s_logIndex++;
        }

        /// <summary>Checks that a log file is valid for deletion. Doesn't throw.</summary>
        /// <param name="fileNameOrPath">The filename or path of the log file.</param>
        /// <returns><see langword="true"/> if <paramref name="fileNameOrPath"/> is a valid path, it's filename is a valid log filename, and it's not the current session's log file.
        /// If one or more of these conditions are not met, <see langword="false"/>.</returns>
        private static bool CanLogFileBeDeleted(string fileNameOrPath)
        {
            try
            {
                return DateTime.TryParseExact(Path.GetFileNameWithoutExtension(fileNameOrPath), Constants.DATE_TIME_FILE_FORMAT, DateTimeFormatInfo.InvariantInfo, DateTimeStyles.None, out _) && fileNameOrPath != Constants.LOG_FILE_PATH;
            }
            catch (ArgumentException)
            {
                return false;
            }
        }
        public static void Dispose()
        {
            // If we dispose the other way around, throws an ObjectDisposedException.
            s_csvWriter.Dispose();
            s_streamWriter.Dispose();
        }
        #endregion Private Methods

        #region Prviate Structs

        ///<remarks>The fields are in the order we want the CSV header to be in. Topmost = leftmost</remarks>
        private struct LogEntry
        {
            #region Public Properties

            public int Index { get; set; }
            public TraceEventType Level { get; set; }
            public string Caller { get; set; }
            public int CallLine { get; set; }
            public string Happening { get; set; }
            public string Message { get; set; }
            public DateTime Date { get; set; }
            public string CallFile { get; set; }
            #endregion Public Properties
        }

        #endregion Private Structs
    }
}
