// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// <Auto-Generated>
// This is here so CodeMaid doesn't reorganize this document
// </Auto-Generated>

using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;

using CsvHelper;
using CsvHelper.Configuration;

using RaphaëlBardini.WinClean.Logic;

namespace RaphaëlBardini.WinClean
{
    /// <summary>Provides CSV and TraceSource logging.</summary>
    public static class LogManager
    {
        #region Private Fields

        private static readonly StreamWriter s_streamWriter = new(Constants.LogFile, true, System.Text.Encoding.Unicode);

        private static readonly CsvWriter s_csvWriter = new(s_streamWriter, new CsvConfiguration(CultureInfo.InvariantCulture) { Delimiter = Constants.LogDelimiter.ToString() });

#if TRACE
        private static readonly TraceSource s_trace = new($"{System.Windows.Forms.Application.ProductName} {System.Windows.Forms.Application.ProductVersion}", Constants.TraceLevel);
#endif

        /// <summary>Count of log entries wrote.</summary>
        private static int s_logIndex = 0;

        #endregion Private Fields

        #region Public Constructors

        static LogManager() => CreateLogDir();

        #endregion Public Constructors

        #region Public Methods

        public static void ClearLogsFolder() => Directory.EnumerateFiles(Constants.LogsDir, "*.csv").Select((fileString) => new Path(fileString))
                        .Where((file) => CanLogFileBeDeleted(file))
                        .ForEach((file) => DeleteLogFile(file));

        public static void Dispose()
        {
            // If disposed the other way around, throws an ObjectDisposedException.
            s_csvWriter.Dispose();
            s_streamWriter.Dispose();
#if TRACE
            s_trace.Close();
#endif
        }

        /// <summary>Logs a string.</summary>
        /// <param name="str">The string to log.</param>
        /// <param name="happening">What we're doing right now.</param>
        /// <param name="lvl">The level of the log entry.</param>
        public static void Log(this string str, string happening, TraceEventType lvl = TraceEventType.Verbose,
                               [CallerMemberName] string caller = "Not Found",
                               [CallerLineNumber] int callLine = 0,
                               [CallerFilePath] string callFile = "Not Found")
        {
            if (s_logIndex == 0)
                WriteHeader(s_csvWriter);
            s_csvWriter.WriteRecord(new LogEntry()
            {
                Date = DateTime.Now,
                Index = s_logIndex,
                Level = lvl,
                Happening = happening,
                Message = str,
                Caller = caller,
                CallFileFullPath = callFile,
                CallLine = callLine
            });
            s_csvWriter.NextRecord();
            s_logIndex++;
#if TRACE
            s_trace.TraceEvent(lvl, s_logIndex, $"{happening} : {str} in {caller} at line {callLine}, in {callFile}");
#endif
        }
        public static void Log(this Exception e, TraceEventType lvl,
                               [CallerMemberName] string caller = "Not Found",
                               [CallerLineNumber] int callLine = 0,
                               [CallerFilePath] string callFile = "Not Found")
            => Log(e?.ToString(), e.Message, lvl, caller, callLine, callFile);
        #endregion Public Methods

        #region Private Methods

        /// <summary>Deletes a log file.</summary>
        /// <param name="fullPath">The full path of the log file to delete.</param>
        /// <exception cref="ArgumentNullException"><paramref name="fullPath"/> is <see langword="null"/>.</exception>
        /// <exception cref="NotSupportedException"><paramref name="fullPath"/> is in an invalid format.</exception>
        /// <exception cref="PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length.</exception>
        private static void DeleteLogFile(Path path)
        {
            try
            {
                File.Delete(path);
            }
            // For IOException, we don't want to handle derived classes. The "is" operator covers derived classes too.
            catch (Exception e) when (e is DirectoryNotFoundException or UnauthorizedAccessException || e.GetType().Equals(typeof(IOException)))
            {
                ErrorDialog.CantDeleteLogFile(e.Message).ShowIgnoreRetry(null,
                onRetry: () =>
                {
                    DeleteLogFile(path);
                }, Program.MainForm);
            }
        }
        /// <summary>Checks that a log file is valid for deletion. Doesn't throw.</summary>
        /// <param name="fileNameOrPath">The filename or path of the log file.</param>
        /// <returns>
        /// <see langword="true"/> if <paramref name="fileNameOrPath"/> is a valid path, it's
        /// filename is a valid log filename, and it's not the current session's log file. If one or
        /// more of these conditions are not met, <see langword="false"/>.
        /// </returns>
        private static bool CanLogFileBeDeleted(Path path)
        {
            try
            {
                return DateTime.TryParseExact(path.FilenameWithoutExtension,
                                              Constants.DateTimeFilenameFormat,
                                              DateTimeFormatInfo.InvariantInfo,
                                              DateTimeStyles.None, out _)
                       && path != Constants.LogFile;
            }
            catch (ArgumentException)
            {
                return false;
            }
        }

        /// <summary>Creates the appropriate log folder if missing.</summary>
        private static void CreateLogDir()
        {
            try
            {
                _ = Directory.CreateDirectory(Constants.LogsDir);
            }
            catch (IOException e)
            {
                ErrorDialog.CantCreateLogDir(e.Message).ShowCloseRetry(Program.Exit, CreateLogDir);
            }
        }

        private static void WriteHeader(in CsvWriter writer)
        {
            writer.WriteHeader<LogEntry>();
            writer.NextRecord();
            s_logIndex++;
        }
        #endregion Private Methods

        #region Private Structs

        ///<remarks>The fields are in the order we want the CSV header to be in. Topmost = leftmost</remarks>
        private struct LogEntry
        {
            #region Public Properties

            public int Index { get; set; }
            public TraceEventType Level { get; set; }
            public int CallLine { get; set; }
            public string Caller { get; set; }
            public string Happening { get; set; }
            public string Message { get; set; }
            public DateTime Date { get; set; }
            public string CallFileFullPath { get; set; }

            #endregion Public Properties
        }

        #endregion Private Structs
    }
}
