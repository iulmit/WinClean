// Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license.
// <Auto-Generated>
// This is here so CodeMaid doesn't reorganize this document
// </Auto-Generated>
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;

using CsvHelper;
using CsvHelper.Configuration;

using RaphaëlBardini.WinClean.Logic;

namespace RaphaëlBardini.WinClean
{
    public enum LogLevel
    {
        Verbose,
        Info,
        Warning,
        Error,
        Critical
    }

    /// <summary>Provides CSV logging.</summary>
    public static class LogManager
    {
        public static LogLevel MinLogLevel { get; set; }
        #region Constants

        /// <summary>Format string used by <see cref="DateTime.ToString(string?)"/> used for NTFS filenames.</summary>
        private const string DateTimeFilenameFormat = "yyyy-MM-dd--HH-mm-ss";

        /// <summary>CSV Log entry column delimiter.</summary>
        private const string LogDelimiter = ";";

        /// <summary>Unique log file that will be used for this session.</summary>
        private static readonly FilePath s_currentLogFile = new(System.IO.Path.Combine(Constants.LogsDir, $"{Process.GetCurrentProcess().StartTime.ToString(DateTimeFilenameFormat, DateTimeFormatInfo.InvariantInfo)}.csv"));

        #endregion Constants

        #region Private Fields

        private static readonly CsvWriter s_csvWriter = new(new StreamWriter(s_currentLogFile, true, System.Text.Encoding.Unicode), new CsvConfiguration(CultureInfo.InvariantCulture) { Delimiter = LogDelimiter });

        /// <summary>Count of log entries wrote.</summary>
        private static int s_logIndex = 0;

        #endregion Private Fields

        #region Public Constructors

        static LogManager() => CreateLogDir();

        #endregion Public Constructors

        #region Public Methods

        public static void ClearLogsFolder()
        {
            IEnumerable<FilePath> deletableLogFiles = Directory.EnumerateFiles(Constants.LogsDir, "*.csv").Select((fileString) => new FilePath(fileString)).Where((file) => CanLogFileBeDeleted(file));
            $"Deleting {deletableLogFiles.Count()} files".Log("Clearing logs folder");
            deletableLogFiles.ForEach((file) => DeleteLogFile(file));
        }

        /// <inheritdoc cref="IDisposable.Dispose"/>
        [Obsolete("Bug in CSV Helper -- Don't use", true)]
        public static void Dispose()
        {
            s_csvWriter.Dispose();
        }

        /// <summary>Logs a string.</summary>
        /// <param name="str">The string to log.</param>
        /// <param name="happening">What we're doing right now.</param>
        /// <param name="lvl">The level of the log entry.</param>
        public static void Log(this string str, string happening, LogLevel lvl = LogLevel.Verbose,
                               [CallerMemberName] string caller = "Not Found",
                               [CallerLineNumber] int callLine = 0,
                               [CallerFilePath] string callFile = "Not Found")
        {
            if (s_logIndex == 0)
            {
                s_csvWriter.WriteHeader<LogEntry>();
                s_csvWriter.NextRecord();
                s_csvWriter.Flush();
                s_logIndex++;
            }
            if (MinLogLevel <= lvl)
            {
                s_csvWriter.WriteRecord(new LogEntry()
                {
                    Date = DateTime.Now,
                    Index = s_logIndex,
                    Level = lvl,
                    Happening = happening,
                    Message = str,
                    Caller = caller,
                    CallFileFullPath = callFile,
                    CallLine = callLine
                });

                s_csvWriter.NextRecord();
                s_csvWriter.Flush();
                s_logIndex++;
            }
        }

        public static void Log(this Exception e, LogLevel lvl,
                               [CallerMemberName] string caller = "Not Found",
                               [CallerLineNumber] int callLine = 0,
                               [CallerFilePath] string callFile = "Not Found")
            => Log((e ?? throw new ArgumentNullException(nameof(e))).ToString(), e.Message, lvl, caller, callLine, callFile);

        #endregion Public Methods

        #region Private Methods

        /// <summary>Checks that a log file is valid for deletion. Doesn't throw.</summary>
        /// <param name="fileNameOrPath">The filename or path of the log file.</param>
        /// <returns>
        /// <see langword="true"/> if <paramref name="fileNameOrPath"/> is a valid path, it's filename is a valid log filename,
        /// and it's not the current session's log file. If one or more of these conditions are not met, <see langword="false"/>.
        /// </returns>
        private static bool CanLogFileBeDeleted(FilePath path)
        {
            try
            {
                return DateTime.TryParseExact(path.FilenameWithoutExtension,
                                              DateTimeFilenameFormat,
                                              DateTimeFormatInfo.InvariantInfo,
                                              DateTimeStyles.None, out _)
                       && path != s_currentLogFile;
            }
            catch (ArgumentException)
            {
                return false;
            }
        }

        /// <summary>Creates the appropriate log folder if missing.</summary>
        private static void CreateLogDir()
        {
            try
            {
                _ = Directory.CreateDirectory(Constants.LogsDir);
            }
            catch (IOException e)
            {
                ErrorDialog.CantCreateLogDir(e.Message, CreateLogDir, Program.Exit);
            }
        }

        /// <summary>Deletes a log file.</summary>
        /// <param name="fullPath">The full path of the log file to delete.</param>
        /// <exception cref="ArgumentNullException"><paramref name="fullPath"/> is <see langword="null"/>.</exception>
        /// <exception cref="NotSupportedException"><paramref name="fullPath"/> is in an invalid format.</exception>
        /// <exception cref="PathTooLongException">
        /// The specified path, file name, or both exceed the system-defined maximum length.
        /// </exception>
        private static void DeleteLogFile(FilePath path)
        {
            try
            {
                File.Delete(path);
            }
            // For IOException, we don't want to handle derived classes. The "is" operator covers derived classes too.
            catch (Exception e) when (e is DirectoryNotFoundException or UnauthorizedAccessException || e.GetType().Equals(typeof(IOException)))
            {
                ErrorDialog.CantDeleteLogFile(e.Message, () => DeleteLogFile(path));
            }
        }

        #endregion Private Methods

        #region Private Structs

        ///<remarks>The fields are in the order we want the CSV header to be in. Topmost = leftmost</remarks>
        private struct LogEntry
        {
            #region Public Properties

            public int Index { get; set; }
            public LogLevel Level { get; set; }
            public int CallLine { get; set; }
            public string Caller { get; set; }
            public string Happening { get; set; }
            public string Message { get; set; }
            public DateTime Date { get; set; }
            public string CallFileFullPath { get; set; }

            #endregion Public Properties
        }

        #endregion Private Structs
    }
}
